# This program automatically pulls RA and DEC of 3I/ATLAS from JPL Horizons API.
# It returns optimal times of observation based on azimuth values between 0 and 90°
# (North-East orientation) and altitude values above 60°


# source: https://ssd.jpl.nasa.gov/horizons/manual.html#observer-table
# GPT/Gemini cross check for troubleshooting

from astroquery.jplhorizons import Horizons
import astropy.units as u
from astropy.coordinates import SkyCoord, AltAz, Angle, EarthLocation
from astropy.time import Time
import pandas as pd
from astropy.table import Table

# can change this depending on desired observation periods:
epochs_dict = {'start': '2025-08-24 00:00',
               'stop': '2025-09-05 00:00',
               'step': '1h'}   # can change to '1d', '1m',...

ROO_loc = {'lon': 145.061634327 * u.deg,
                     'lat': -37.680589141 * u.deg,
                     'elevation': 0.155083 * u.m}
obj = Horizons(id='C/2025 N1', location=ROO_loc, epochs=epochs_dict)

ephem = obj.ephemerides(quantities='1,20')   # quantities are column number
                                             # 1 for astrometric RA and DEC,
                                             # 20 for magnitude

data_wanted = ephem['datetime_str', 'RA', 'DEC', 'M1']
# print(data_wanted)

# print(ephem)   # contains following column names: <TableColumns
# names=('targetname','datetime_str','datetime_jd','M1','solar_presence',
# 'k1','lunar_presence','RA','DEC','delta','delta_rate')>

# print(ephem.columns)   # all

#################################################################

# feeding coordinates to astropy in a format where it recognises what they mean:
ROO_loc_astropy = EarthLocation(lon=145.061634327 * u.deg,
                     lat=-37.680589141 * u.deg,
                     height=0.155083 * u.m)

# converting the RA and DEC columns to astropy angle objects:
RA_angles = Angle(ephem['RA'])
DEC_angles = Angle(ephem['DEC'])

# converting horizons table to pandas for easier datetime parsing:
ephem = ephem.to_pandas()

# converting horizons datetime string to pandas datetime:
ephem['datetime_obj'] = pd.to_datetime(ephem['datetime_str'])

# converting the pandas datetime series to a list of datetime objects:
datetime_list = ephem['datetime_obj'].tolist()

# converting list of datetime objects to an astropy time object:
times = Time(datetime_list, format='datetime', scale = 'utc')

# defining skycoords object:
skycoords = SkyCoord(ra=RA_angles, dec=DEC_angles, frame='icrs')
# 'RA' and 'DEC' are in degrees

altaz = skycoords.transform_to(AltAz(obstime=times, location=ROO_loc_astropy))
# print("Altitude (deg):", altaz.alt.deg)
# print("Azimuth (deg):", altaz.az.deg)

# MAKING TABLE OF ALL DATA REQUIRED:
table = Table()
table['Date_Time'] = ephem['datetime_str']
table['RA (deg)'] = ephem['RA']
table['DEC (deg)'] = ephem['DEC']
table['Magnitude'] = ephem['M1']
table['Altitude (deg)'] = altaz.alt
table['Azimuth (deg)'] = altaz.az

# showing all table columns (no wrapping) using a string Pandas DataFrame:
print(table.to_pandas().to_string(index=False))

def optimal_times(table):
    for row in table:
        azimuth = row['Azimuth (deg)']
        altitude = row['Altitude (deg)']
        if (azimuth <= 90 and altitude >= 60):
            print (row['Date_Time'])

print ('\n', '\n', "Optimal dates and times for observation:", '\n')
optimal_times(table)
